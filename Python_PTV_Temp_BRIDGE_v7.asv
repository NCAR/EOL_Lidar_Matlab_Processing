clear all; close all

% --- 1. CONFIGURATION AND PATHS ---
node = 'MPD04';
% Use fullfile for robust path definition
serv_path = '/Volumes/eol/sci/mhayman';
%serv_path = '/Volumes/sci/mhayman';
plot_path = '/Users/spuler/Desktop';

data_dir = fullfile(serv_path, 'DIAL', 'Processed_Data', 'BRIDGE_2025', 'ptv0.7');
plot_dir = fullfile(plot_path, 'mpd', 'Plots');

addpath('/Users/spuler/Documents/GitHub/EOL_Lidar_Matlab_Processing/PlotFunctions'); 
addpath '/Users/spuler/Documents/GitHub/EOL_Lidar_Matlab_Processing/matplotlib/';
addpath '/Users/spuler/Documents/GitHub/EOL_Lidar_Matlab_Processing'

flag.save_data = 0;  %save data at end of processing (0=off 1=on)
low_range_mask = 0;

% --- PLOTTING EXCLUSION FLAGS (0=Exclude/Off, 1=Include/On) ---
flag.plot_aerosol_counts = 0;  % Toggle multi panel aersol overview
flag.plot_multi_temp = 1;      % Toggle multi panel T WV abs 
flag.plot_multi_wv = 1;        % Toggle multi panel T WV diff
flag.plot_single_temp_panels = 0; 
flag.plot_single_wv_panels = 0;   
flag.plot_uncertainty = 0;     
flag.plot_histograms_2d = 1;   % Toggle 2D Density Maps (T_Range, AH_Range)
flag.plot_ah_density_map = 1;  % Toggle AH vs ERA5 Density Map
flag.plot_t_density_map = 1;   % Toggle Temp vs ERA5 Density Map
flag.plot_1d_histograms = 0;   % Toggle 1D Histograms (T_Diff_Histogram, AH_Diff_Histogram)
flag.plot_profile_lines = 0;   % Toggle vertical profile line plots for a specific time/date5

% --- PROFILE PLOT SETTINGS ---
PROFILE_TIME_TO_PLOT = datenum('2025-07-29 07:00:00', 'yyyy-mm-dd HH:MM:SS'); 

% --- DATA READING EXCLUSION FLAGS (0=Exclude/Off, 1=Include/On) ---
flag.read_temp_std = 1;        % Include reading Temperature_Standard and related fields
flag.read_wv_multi = 1;        % Include reading Absolute_Humidity_MultiPulse fields

% --- PLOTTING RESOLUTION SETTING ---
TARGET_PIXEL_WIDTH = 10000;     % Target output width (pixels) for visual quality (used to calculate N_DECIMATE)
flag.decimate_hist_data = 1;   % 0 = Use FULL RESOLUTION data for 2D Histograms (High Accuracy, Slower)
% -----------------------------------

disp('--- Script Start ---');
tic_total = tic; % Start total timing

cd(data_dir); % Move to data directory to select files

% --- 2. FILE SELECTION ---
[Pythonfilename, Pythondir] = uigetfile('*.*','Select the sonde file', 'MultiSelect', 'on');
num_files = size(Pythonfilename, 2);

if num_files == 0
    error('No files selected. Script terminated.');
end

% --- 3. VARIABLE DEFINITION ---
variables = cell(1, 41);
variables([1:12, 13:15, 16:18, 26:28, 30:32, 40:41]) = {
    'time', 'range', 'Temperature_PTV', 'Temperature_PTV_mask', 'Temperature_PTV_uncertainty', ...
    'Absolute_Humidity_Standard', 'Absolute_Humidity_Standard_mask', 'Absolute_Humidity_Standard_uncertainty', ...
    'Aerosol_Backscatter_Coefficient_PTV', 'Aerosol_Backscatter_Coefficient_PTV_mask', ...
    'Aerosol_Backscatter_Coefficient_PTV_uncertainty', 'Backscatter_Photon_Counts_828', ...
    'Temperature_Standard', 'Temperature_Standard_mask', 'Temperature_Standard_uncertainty', ... 
    'Absolute_Humidity_PTV', 'Absolute_Humidity_PTV_mask', 'Absolute_Humidity_PTV_uncertainty', ...
    'Absolute_Humidity_MultiPulse', 'Absolute_Humidity_MultiPulse_mask', 'Absolute_Humidity_MultiPulse_uncertainty', ...
    'Surface_Temperature', 'Surface_Pressure', 'Surface_Absolute_Humidity', ...
    'Absolute_Humidity_ERA5', 'Temperature_ERA5'
};

% --- 4. DATA READING AND MASKING LOOP (Conditional Reading) ---
disp('Starting data reading and masking...');
tic_read = tic;

for jj = 1:num_files
    filename = Pythonfilename{jj};
    date_str = filename(end-15:end-8);
    n = datenum(date_str, 'yyyymmdd');
    
    ncid = netcdf.open(filename, 'NC_NOWRITE');
   % ncdisp(filename, '/', 'min') % use this to display all variables

    % Read data (Base variables - always read)
    time{jj} = ncread(filename,variables{1}); 
    alt{jj} = ncread(filename,variables{2});
        
    % Get dimensions for fallback NaNs
    num_ranges_file = size(alt{jj}, 1);
    num_timesteps_file = size(time{jj}, 1);
 
    % Temperature PTV (Always read, but uncertainty is conditional)
    T{jj}  = ncread(filename,variables{3});  
    T_mask{jj} = ncread(filename,variables{4}); 
    T_model{jj}  = ncread(filename,variables{41}); 
    T_var{jj} = ncread(filename,variables{5}); 

    % Conditional: Temperature Standard 
    if flag.read_temp_std % Include reading T_Std if flag is 1
        T_Std{jj}  = ncread(filename,variables{13});  
        T_Std_mask{jj} = ncread(filename,variables{14}); 
        T_Std_var{jj} = ncread(filename,variables{15}); 

    else
        % Fill with NaNs if excluding (flag.read_temp_std is 0)
        T_Std{jj} = nan(num_ranges_file, num_timesteps_file);
        T_Std_mask{jj} = nan(num_ranges_file, num_timesteps_file);
        T_Std_var{jj} = nan(num_ranges_file, num_timesteps_file);
    end
    
    % Surface Data 
    T_surf{jj} =  ncread(filename,variables{30});
    P_surf{jj} =  ncread(filename,variables{31});
    AH_surf{jj} =  ncread(filename,variables{32});
    
    % Absolute Humidity Standard 
    AH{jj}  = ncread(filename,variables{6});  
    AH_mask{jj} = ncread(filename,variables{7}); 
    AH_PTV{jj}  = ncread(filename,variables{16});  
    AH_PTV_mask{jj} = ncread(filename,variables{17}); 
    AH_model{jj}  = ncread(filename,variables{40});  
    AH_var{jj} = ncread(filename,variables{8}); 
    AH_PTV_var{jj} = ncread(filename,variables{18});


    % Conditional: Absolute Humidity MultiPulse
    if flag.read_wv_multi % Include reading MultiPulse data if flag is 1
        try
          AH_MultiPulse{jj}  = ncread(filename,variables{26});  
          AH_MultiPulse_mask{jj} = ncread(filename,variables{27}); 
          AH_MultiPulse_var{jj} = ncread(filename,variables{28});
        catch
           warning(['MultiPulse data missing in file: ', filename]);
           AH_MultiPulse{jj} = nan(num_ranges_file, num_timesteps_file);
           AH_MultiPulse_mask{jj} = nan(num_ranges_file, num_timesteps_file);
           AH_MultiPulse_var{jj} = nan(num_ranges_file, num_timesteps_file);
        end
    else
        % Fill with NaNs if excluding
        AH_MultiPulse{jj} = nan(num_ranges_file, num_timesteps_file);
        AH_MultiPulse_mask{jj} = nan(num_ranges_file, num_timesteps_file);
        AH_MultiPulse_var{jj} = nan(num_ranges_file, num_timesteps_file);
    end
    
    % ABC/Counts
    ABC{jj}  = ncread(filename,variables{9});   
    ABC_mask{jj} = ncread(filename,variables{10}); 
    Counts{jj} = ncread(filename,variables{12});   
    ABC_var{jj} = ncread(filename,variables{11});

    % --- MASKING ---
    T{jj}(T_mask{jj} == 1) = nan;
    T_var{jj}(T_mask{jj} == 1) = nan; 
    T_Std{jj}(T_Std_mask{jj} == 1) = nan;
    T_Std_var{jj}(T_Std_mask{jj} == 1) = nan; 
    mask_ah = (AH_mask{jj} == 1) | (AH_var{jj} > 25);
    AH{jj}(mask_ah) = nan;
    AH_var{jj}(AH_mask{jj} == 1) = nan; 
    mask_ah1 = (AH_PTV_mask{jj} == 1) | (AH_PTV_var{jj} > 25);
    AH_PTV{jj}(mask_ah1) = nan;
    AH_PTV_var{jj}(AH_PTV_mask{jj} == 1) = nan; 
    mask_ah2 = (AH_MultiPulse_mask{jj} == 1) | (AH_MultiPulse_var{jj} > 25);
    AH_MultiPulse{jj}(mask_ah2) = nan;
    AH_MultiPulse_var{jj}(AH_MultiPulse_mask{jj} == 1) = nan; 
    ABC{jj}(ABC_mask{jj} == 1) = nan;

    CORRUPTED_ROWS = [42:66];
    AH_PTV{jj}(CORRUPTED_ROWS, :) = NaN;

    netcdf.close(ncid); 
  
     
    % Convert from Unix time to date number
    duration{jj} = n + double(time{jj}/86400); % 86400 = 3600*24
end

disp(['Data reading and masking complete. Time elapsed: ', num2str(toc(tic_read)), ' seconds.']);

% --- TEST FOR RANGE GATE CONSISTENCY ---
disp(' ');
disp('--- STARTING RANGE GATE CONSISTENCY CHECK ---');

% Get the number of vertical range gates (rows) for the AH matrix in each file
all_num_ranges = cellfun('size', AH, 1);
num_files = length(AH); % Use the actual number of files read

% Get the filename strings for display
file_names = Pythonfilename;

% Display the range gate count for each file
for jj = 1:num_files
    fprintf('File %d: %s | Range Gates (Rows): %d\n', jj, file_names{jj}, all_num_ranges(jj));
end

% Identify min, max, and unique counts
min_ranges = min(all_num_ranges);
max_ranges = max(all_num_ranges);
unique_ranges = unique(all_num_ranges);

disp(' ');
fprintf('Minimum Range Gates found: %d\n', min_ranges);
fprintf('Maximum Range Gates found: %d\n', max_ranges);

if length(unique_ranges) > 1
    disp('*** Inconsistent vertical range gate count found! ***');
    fprintf('Unique range counts: %s\n', num2str(unique_ranges));
else
    disp('Range gate count is consistent across all files');
end
disp('--- END RANGE GATE CONSISTENCY CHECK ---');
disp(' ');
% --------------------------------------------------


% --- 5. PREALLOCATION AND COMBINATION ---
disp('Starting data combination...');
tic_combine = tic;

total_timesteps = sum(cellfun('size', duration, 1)); 
num_ranges = size(AH{1}, 1); 

% -----------------------------------------------------------
% --- FULL RESOLUTION COPIES (For Histograms if NOT decimating and for profile plots) ---
% -----------------------------------------------------------
comb_AH_full = nan(num_ranges, total_timesteps);
comb_AH_var_full = nan(num_ranges, total_timesteps);
comb_AH_PTV_full = nan(num_ranges, total_timesteps);
comb_AH_PTV_var_full = nan(num_ranges, total_timesteps);
comb_AH_MultiPulse_full = nan(num_ranges, total_timesteps);
comb_AH_model_full = nan(num_ranges, total_timesteps);
comb_ABC_full = nan(num_ranges, total_timesteps);
comb_T_full = nan(num_ranges, total_timesteps);
comb_T_Std_full = nan(num_ranges, total_timesteps);
comb_T_model_full = nan(num_ranges, total_timesteps);


% -----------------------------------------------------------------------
% --- DECIMATED/BASE COPIES (These are the main variables used for pcolor) ---
% -----------------------------------------------------------------------
comb_AH = nan(num_ranges, total_timesteps);
comb_AH_var = nan(num_ranges, total_timesteps);
comb_AH_PTV = nan(num_ranges, total_timesteps);
comb_AH_PTV_var = nan(num_ranges, total_timesteps);
comb_AH_MultiPulse = nan(num_ranges, total_timesteps);
comb_AH_MultiPulse_var = nan(num_ranges, total_timesteps);
comb_AH_model = nan(num_ranges, total_timesteps);
comb_ABC = nan(num_ranges, total_timesteps);
comb_ABC_var = nan(num_ranges, total_timesteps);
comb_T = nan(num_ranges, total_timesteps);
comb_T_var = nan(num_ranges, total_timesteps);
comb_T_Std = nan(num_ranges, total_timesteps); 
comb_T_Std_var = nan(num_ranges, total_timesteps); 
comb_T_model = nan(num_ranges, total_timesteps);
comb_Counts = nan(num_ranges, total_timesteps);

% Preallocate 1D arrays
comb_duration = nan(total_timesteps, 1);
comb_T_surf = nan(total_timesteps, 1); 
comb_P_surf = nan(total_timesteps, 1); 
comb_AH_surf = nan(total_timesteps, 1); 

start_col = 1;

for jj = 1:num_files
    current_timesteps = size(AH{jj}, 2); 
    end_col = start_col + current_timesteps - 1;

    % Fill 1D data
    comb_duration(start_col:end_col) = duration{jj};
    comb_T_surf(start_col:end_col) = T_surf{jj};
    comb_P_surf(start_col:end_col) = P_surf{jj};
    comb_AH_surf(start_col:end_col) = AH_surf{jj};
    
    % Fill 2D data:
    
    % Full Resolution Copies (Filled unconditionally for histogram option)
    comb_AH_full(:, start_col:end_col) = AH{jj};
    comb_AH_var_full(:, start_col:end_col) = AH_var{jj};
    comb_AH_PTV_full(:, start_col:end_col) = AH_PTV{jj};
    comb_AH_PTV_var_full(:, start_col:end_col) = AH_PTV_var{jj};
    comb_AH_MultiPulse_full(:, start_col:end_col) = AH_MultiPulse{jj};
    comb_AH_model_full(:, start_col:end_col) = AH_model{jj};
    comb_T_full(:, start_col:end_col) = T{jj};
    comb_T_Std_full(:, start_col:end_col) = T_Std{jj}; 
    comb_T_model_full(:, start_col:end_col) = T_model{jj};
    comb_ABC_full(:, start_col:end_col) = ABC{jj};
    
    % Decimated Copies (Base variables)
    comb_AH(:, start_col:end_col) = AH{jj};
    comb_AH_var(:, start_col:end_col) = AH_var{jj};
    comb_AH_PTV(:, start_col:end_col) = AH_PTV{jj};
    comb_AH_PTV_var(:, start_col:end_col) = AH_PTV_var{jj};
    comb_AH_MultiPulse(:, start_col:end_col) = AH_MultiPulse{jj};
    comb_AH_MultiPulse_var(:, start_col:end_col) = AH_MultiPulse_var{jj};
    comb_AH_model(:, start_col:end_col) = AH_model{jj};
    comb_ABC(:, start_col:end_col) = ABC{jj};
    comb_ABC_var(:, start_col:end_col) = ABC_var{jj};
    comb_T(:, start_col:end_col) = T{jj};
    comb_T_var(:, start_col:end_col) = T_var{jj};
    comb_T_Std(:, start_col:end_col) = T_Std{jj}; 
    comb_T_Std_var(:, start_col:end_col) = T_Std_var{jj}; 
    comb_T_model(:, start_col:end_col) = T_model{jj};
    comb_Counts(:, start_col:end_col) = Counts{jj}; 
    
    start_col = end_col + 1;
end

disp(['Data combination complete. Time elapsed: ', num2str(toc(tic_combine)), ' seconds.']);

% --- NaN GAP INSERTION FOR VISUAL BREAKS ---
disp('Starting gap insertion...');
tic_gap = tic;

% Calculate the time difference (in days) between consecutive profiles
dt = diff(comb_duration);

% Gap threshold: If the time jump is greater than 2 days, assume it's a data gap
gap_threshold = 2.0; 

% Find indices immediately preceding a gap
gap_indices = find(dt > gap_threshold);

% Combine all variables for gap insertion
data_arrays_2d_all = {'comb_AH', 'comb_AH_var', 'comb_AH_PTV', 'comb_AH_PTV_var', 'comb_AH_MultiPulse', 'comb_AH_MultiPulse_var', 'comb_AH_model', 'comb_ABC', 'comb_ABC_var', 'comb_T', 'comb_T_var', 'comb_T_Std', 'comb_T_Std_var', 'comb_T_model', 'comb_Counts', ...
                  'comb_AH_full', 'comb_AH_var_full', 'comb_AH_PTV_full', 'comb_AH_PTV_var_full', 'comb_AH_MultiPulse_full', 'comb_AH_model_full', 'comb_ABC_full', 'comb_T_full', 'comb_T_Std_full', 'comb_T_model_full'};

data_arrays_1d = {'comb_duration', 'comb_T_surf', 'comb_P_surf', 'comb_AH_surf'};

if ~isempty(gap_indices)
    disp(['Found ', num2str(length(gap_indices)), ' time gaps exceeding ', num2str(gap_threshold), ' days. Inserting 2 NaNs...']);
    
    % Loop through the detected gaps in reverse order to maintain correct indexing
    for i = length(gap_indices):-1:1
        idx = gap_indices(i); % Index *before* the gap starts
        
        gap_start_time = comb_duration(idx);
        gap_end_time = comb_duration(idx + 1);
        
        % Define two insertion time points to span the gap visually:
        nan_time_1 = gap_start_time + (gap_end_time - gap_start_time) * 0.001;
        nan_time_2 = gap_end_time - (gap_end_time - gap_start_time) * 0.001;

        % --- Insert two NaN rows into 1D arrays (duration and surface data) ---
        for arr = data_arrays_1d
            array_name = arr{1};
            current_array = eval(array_name);
            
            % Set insertion values (Time for duration, NaN for surface data)
            nan_val_1 = NaN;
            nan_val_2 = NaN;
            if strcmp(array_name, 'comb_duration')
                nan_val_1 = nan_time_1; 
                nan_val_2 = nan_time_2; 
            end
            
            % Insert the two new rows/values at index idx + 1 and idx + 2
            current_array = [current_array(1:idx); nan_val_1; nan_val_2; current_array(idx+1:end)];
            eval([array_name ' = current_array;']);
        end
        
        % --- Insert two NaN columns into 2D arrays ---
        nan_cols = nan(num_ranges, 2);
        for arr = data_arrays_2d_all
            array_name = arr{1};
            % Check if variable exists before trying to evaluate/modify
            if exist(array_name, 'var')
                current_array = eval(array_name);
                % Insert the two NaN columns at index idx + 1
                current_array = [current_array(:, 1:idx), nan_cols, current_array(:, idx+1:end)];
                eval([array_name ' = current_array;']);
            end
        end
    end
else
    disp('No significant time gaps found.');
end

disp(['Gap insertion complete. Time elapsed: ', num2str(toc(tic_gap)), ' seconds.']);

% --- AVAILABILITY CALCULATION (FOR PLOT ANNOTATION) ---
disp('Starting availability calculation...');
MAX_ALT_KM = 3.0; % The cutoff for low-altitude availability
y_alt_km = (alt{1}./1000); % y is defined later, use the original alt array

% Use full resolution matrices for the most accurate statistics
avail.T_PTV = calculate_low_range_availability(comb_T_full, y_alt_km, MAX_ALT_KM);
avail.T_Std = calculate_low_range_availability(comb_T_Std_full, y_alt_km, MAX_ALT_KM);
avail.AH_PTV = calculate_low_range_availability(comb_AH_PTV_full, y_alt_km, MAX_ALT_KM);
avail.AH_Std = calculate_low_range_availability(comb_AH_full, y_alt_km, MAX_ALT_KM);
avail.AH_MultiPulse = calculate_low_range_availability(comb_AH_MultiPulse_full, y_alt_km, MAX_ALT_KM);

disp('Availability calculation complete.');
% -----------------------------------------------------

% --- APPLY SMART DECIMATION HERE ---
disp('Starting smart decimation...');
tic_decimate = tic;

% 1. DYNAMICALLY CALCULATE N_DECIMATE
N_time_actual = length(comb_duration);
% Calculate factor, ensuring minimum decimation of 1
N_DECIMATE_DYNAMIC = max(1, floor(N_time_actual / TARGET_PIXEL_WIDTH));
disp(['Calculated dynamic decimation factor N = ', num2str(N_DECIMATE_DYNAMIC), '.']);

% List of DECIMATED 2D matrices (only comb_* variables are used for pcolor plots)
decimate_vars = {'comb_AH', 'comb_AH_var', 'comb_AH_PTV', 'comb_AH_PTV_var', 'comb_AH_MultiPulse', 'comb_AH_MultiPulse_var', 'comb_AH_model', 'comb_ABC', 'comb_ABC_var', 'comb_T', 'comb_T_var', 'comb_T_Std', 'comb_T_Std_var', 'comb_T_model', 'comb_Counts'};

% Decimate each 2D matrix
for i = 1:length(decimate_vars)
    var_name = decimate_vars{i};
    current_matrix = eval(var_name);
    
    if ~isempty(current_matrix)
        % Overwrite the full-resolution variable with the decimated version
        decimated_matrix = decimate_matrix(current_matrix, N_DECIMATE_DYNAMIC);
        eval([var_name ' = decimated_matrix;']);
    end
end

% Decimate the time axis (x-axis) to match the new DECIMATED data
N_total = length(comb_duration);
comb_duration_decimated = comb_duration(1:N_DECIMATE_DYNAMIC:N_total);

% Overwrite the old x-axis variable with the decimated version
x = comb_duration_decimated;

disp(['Decimation complete. Time elapsed: ', num2str(toc(tic_decimate)), ' seconds.']);



% --- QUANTITATIVE COMPARISON: ACCURACY & PRECISION ---
T_tolerance = 3.0; 
num_ranges_dec = size(comb_T, 1);
y_diag = (alt{1}./1000); 

% Preallocate
acc_PTV_prof = nan(num_ranges_dec, 1);  acc_Std_prof = nan(num_ranges_dec, 1);
bias_PTV_prof = nan(num_ranges_dec, 1); bias_Std_prof = nan(num_ranges_dec, 1);
width_PTV_prof = nan(num_ranges_dec, 1); width_Std_prof = nan(num_ranges_dec, 1);
prec_PTV_prof = nan(num_ranges_dec, 1); prec_Std_prof = nan(num_ranges_dec, 1);

for i = 1:num_ranges_dec
    T_ref = comb_T_model(i, :);
    
    % PTV Calculations
    diff_PTV = comb_T(i, :) - T_ref;
    v_PTV = isfinite(diff_PTV);
    if sum(v_PTV) > 10
        valid_PTV = diff_PTV(v_PTV);
        m_bias = median(valid_PTV);
        acc_PTV_prof(i) = (sum(abs(valid_PTV) <= T_tolerance) / length(valid_PTV)) * 100;
        bias_PTV_prof(i) = m_bias;
        width_PTV_prof(i) = prctile(abs(valid_PTV), 90); % Total Error
        prec_PTV_prof(i) = prctile(abs(valid_PTV - m_bias), 90); % Spread only
    end
    
    % Standard Calculations
    diff_Std = comb_T_Std(i, :) - T_ref;
    v_Std = isfinite(diff_Std);
    if sum(v_Std) > 10
        valid_Std = diff_Std(v_Std);
        m_bias_std = median(valid_Std);
        acc_Std_prof(i) = (sum(abs(valid_Std) <= T_tolerance) / length(valid_Std)) * 100;
        bias_Std_prof(i) = m_bias_std;
        width_Std_prof(i) = prctile(abs(valid_Std), 90); % Total Error
        prec_Std_prof(i) = prctile(abs(valid_Std - m_bias_std), 90); % Spread only
    end
end



% Create a diagnostic table for manual inspection
DiagnosticTable = table(y_diag(1:num_ranges_dec), counts_PTV, bias_PTV_prof, width_PTV_prof, acc_PTV_prof, ...
    'VariableNames', {'Altitude_km', 'ValidPoints', 'MedianBias_K', 'ErrorEnvelope_90th_K', 'Accuracy_3K_Pct'});

disp('Troubleshooting: "DiagnosticTable" created in Workspace. Open it to inspect values.');





% --- 6. PLOT SETUP AND CALLS (Conditional Plotting Implemented) ---
disp('Starting plotting and saving...');
tic_plot_save = tic;

scrsz = get(0,'ScreenSize');
date_str = datestr(comb_duration(1), 'yyyy-mmm-dd'); % Use first day of combined data
plot_size_wide = [scrsz(4)/1.5 scrsz(4)/10 scrsz(3)/1.5 scrsz(4)/3]; % Used for single plots
plot_size_5panel = [100 100 1200 800]; % Custom size for 5 vertical panels (Figure 1 uses this)
plot_size_7panel = [100 100 1200 1100]; % Custom size for 7 vertical panels (Figure 2 uses this)
plot_size_square = [100 100 750 750];

font_size = 20; % ORIGINAL FONT SIZE FOR ALL SINGLE PANEL PLOTS
font_size_small = 8; % REDUCED FONT SIZE FOR MULTI-PANEL PLOTS
y = (alt{1}./1000); % Assumes 'alt' is consistent across files

% --- DYNAMIC TICK MARK CALCULATION (FUNCTION CALL) ---
disp('Calculating dynamic tick interval...');
[xData, xData_m] = calculate_plot_ticks(x); % x is the decimated time axis
% ------------------------------------------


% Call the Local Function to Generate the Colormap (N_colors, max_value, max_gray_value)---
smooth_gray_cmap_T  = create_diverging_cmap(64, 5, 1);
smooth_gray_cmap_AH = create_diverging_cmap(64, 5, 1);


% Define PLASMAP_CMAP as a matrix, necessary for stable subplot colormaps
plasma_cmap = plasma(64); % Assuming 'plasma' is available/defined

% Define common parameters for plots
cmap_AH = CM_YlGnBu(64); % CM_YlGnBu is a custom function
caxis_AH = [0 25];
caxis_diff_AH = [-5 5];
caxis_diff_T = [-5 5];
caxis_uncertainty = [-5 5]; 
caxis_T_abs = [265 305];
caxis_ABC = [5e-9 1e-6];
caxis_Counts = [1e2 1e6];

% === HISTOGRAM/DENSITY MAP PARAMETER DEFINITIONS (FIXED LOCATION) ===
AH_diff_bin_limits = [-10 10];
T_diff_bin_limits = [-10 10]; %
DENSITY_CLIM = [1e-4 1e-2]; % for ERA5Global Density Plot CLim ---
AH_density_limits = [0 25];  % Absolute Humidity (g/m3)
T_density_limits = [265 305]; % Temperature (K)
T_hist_limits = [-15 15];
AH_hist_limits = [-10 10];

T_diff_bin_width = 0.2;
AH_diff_bin_width = 0.2;

cmap_density = flipud(magma(256));
% ====================================================================

figure_idx = 1;
figure_list = {}; % Dynamic list to store figure numbers that were actually created
suffix_list = {}; % Dynamic list to store suffixes for figures that were actually created

% --- FIX: Normalized Plotting Coordinates for Subplot Alignment ---
SUBPLOT_LEFT = 0.1;
SUBPLOT_WIDTH = 0.78; 


% ---------------------------------------------
% 7-PANEL ABSOLUTE VALUES (AH & T) ---
% ---------------------------------------------
if flag.plot_multi_temp % Keeping the flag name, but changing its function
    hf = create_7panel_absolute_plot(flag, node, comb_AH, comb_AH_PTV, comb_AH_MultiPulse, comb_AH_model, ...
        comb_T, comb_T_Std, comb_T_model, x, y, avail, caxis_AH, cmap_AH, caxis_T_abs, plasma_cmap, ...
        MAX_ALT_KM, font_size_small, plot_size_7panel, xData, xData_m);
        
    figure_list{end+1} = figure_idx;
    suffix_list{end+1} = 'T_WV_7Panel_Absolute'; % NEW SUFFIX
    figure_idx=figure_idx+1; % Increment figure index
end


% ---------------------------------------------------
% 7-PANEL DIFFERENCES (AH & T) ---
% ---------------------------------------------------
if flag.plot_multi_wv % Keeping the flag name, but changing its function
    hf = create_7panel_difference_plot(flag, node, comb_AH, comb_AH_PTV, comb_AH_MultiPulse, comb_AH_model, ...
        comb_T, comb_T_Std, comb_T_model, x, y, avail, caxis_AH, cmap_AH, caxis_diff_AH, smooth_gray_cmap_AH, ...
        caxis_T_abs, caxis_diff_T, smooth_gray_cmap_T, plasma_cmap, MAX_ALT_KM, font_size_small, plot_size_7panel, xData, xData_m);

    figure_list{end+1} = figure_idx;
    suffix_list{end+1} = 'T_WV_7Panel_Difference'; % NEW SUFFIX
    figure_idx=figure_idx+1; % Increment figure index
end


% ---------------------------------------------
% 4-PANEL CORE PARAMETERS (Counts, ABC, AH, T) ---
% ---------------------------------------------
if flag.plot_aerosol_counts % Using this flag to control the new plot
    
    hf = create_4panel_core_plot(node, comb_Counts, comb_ABC, comb_AH_PTV, comb_T, x, y, avail, ...
        caxis_Counts, caxis_ABC, caxis_AH, cmap_AH, caxis_T_abs, plasma_cmap, ...
        MAX_ALT_KM, font_size_small, plot_size_4panel, xData, xData_m);

    figure_list{end+1} = figure_idx;
    suffix_list{end+1} = 'Core_4Panel_Parameters';
    figure_idx=figure_idx+1; % Increment figure index
end


% ---------------------------------------------------
% --- SINGLE-PANEL PLOTS (CONDITIONAL) ---
% ---------------------------------------------------

% Single Temperature and WV panels (REDUNDANT with multi-plots, only run if requested)
if flag.plot_single_temp_panels || flag.plot_single_wv_panels
    warning('Redundant single plots enabled. Use flag.plot_single_*_panels=0 for efficiency.');
end

% Single Temperature Panels 
if flag.plot_single_temp_panels
    % T_model
    create_pcolor_plot(x, y, comb_T_model, 'Temp, ERA5 Model (K)', caxis_T_abs, plasma_cmap, node, plot_size_wide, font_size, xData, xData_m, figure_idx, 0); 
    figure_list{end+1} = figure_idx; suffix_list{end+1} = 'T_Model_multi'; figure_idx=figure_idx+1;
    
    % T_PTV
    create_pcolor_plot(x, y, comb_T, 'Temp, PTV (K)', caxis_T_abs, plasma_cmap, node, plot_size_wide, font_size, xData, xData_m, figure_idx, 0); 
    figure_list{end+1} = figure_idx; suffix_list{end+1} = 'T_PTV_multi'; figure_idx=figure_idx+1;
    
    if flag.read_temp_std
        % T_Std
        create_pcolor_plot(x, y, comb_T_Std, 'Temp, Standard (K)', caxis_T_abs, plasma_cmap, node, plot_size_wide, font_size, xData, xData_m, figure_idx, 0); 
        figure_list{end+1} = figure_idx; suffix_list{end+1} = 'T_Standard_multi'; figure_idx=figure_idx+1;

        % T_Std Difference
        create_pcolor_plot(x, y, comb_T_Std-comb_T_model, 'Temperature, Standard-ERA5 (K)', caxis_diff_T, smooth_gray_cmap_T, node, plot_size_wide, font_size, xData, xData_m, figure_idx, 0);
        figure_list{end+1} = figure_idx; suffix_list{end+1} = 'T_Diff_Standard_Model'; figure_idx=figure_idx+1;
    end
    
    % T_PTV Difference
    create_pcolor_plot(x, y, comb_T-comb_T_model, 'Temperature, PTV-ERA5 (K)', caxis_diff_T, smooth_gray_cmap_T, node, plot_size_wide, font_size, xData, xData_m, figure_idx, 0);
    figure_list{end+1} = figure_idx; suffix_list{end+1} = 'T_Diff_PTV_Model'; figure_idx=figure_idx+1;
end

% Single Water Vapor Panels 
if flag.plot_single_wv_panels
    % Absolute AH plots
    create_pcolor_plot(x, y, comb_AH, 'Absolute Humidity Standard (g m^{-3})', caxis_AH, cmap_AH, node, plot_size_wide, font_size, xData, xData_m, figure_idx, 0); 
    figure_list{end+1} = figure_idx; suffix_list{end+1} = 'WV_Standard_multi'; figure_idx=figure_idx+1;

    create_pcolor_plot(x, y, comb_AH_PTV, 'Absolute Humidity PTV (g m^{-3})', caxis_AH, cmap_AH, node, plot_size_wide, font_size, xData, xData_m, figure_idx, 0); 
    figure_list{end+1} = figure_idx; suffix_list{end+1} = 'WV_PTV_multi'; figure_idx=figure_idx+1;

    if flag.read_wv_multi
        create_pcolor_plot(x, y, comb_AH_MultiPulse, 'Absolute Humidity MultiPulse (g m^{-3})', caxis_AH, cmap_AH, node, plot_size_wide, font_size, xData, xData_m, figure_idx, 0); 
        figure_list{end+1} = figure_idx; suffix_list{end+1} = 'WV_MultiPulse_multi'; figure_idx=figure_idx+1;
    end
    
    create_pcolor_plot(x, y, comb_AH_model, 'Absolute Humidity ERA5 Model (g m^{-3})', caxis_AH, cmap_AH, node, plot_size_wide, font_size, xData, xData_m, figure_idx, 0); 
    figure_list{end+1} = figure_idx; suffix_list{end+1} = 'WV_Model_multi'; figure_idx=figure_idx+1;

    % Difference AH plots
    create_pcolor_plot(x, y, comb_AH-comb_AH_model, 'Absolute Humidity Standard-ERA5 (g m^{-3})', caxis_diff_AH, smooth_gray_cmap_AH, node, plot_size_wide, font_size, xData, xData_m, figure_idx, 0); 
    figure_list{end+1} = figure_idx; suffix_list{end+1} = 'WV_Diff_Standard_Model'; figure_idx=figure_idx+1;

    create_pcolor_plot(x, y, comb_AH_PTV-comb_AH_model, 'Absolute Humidity PTV-ERA5 (g m^{-3})', caxis_diff_AH, smooth_gray_cmap_AH, node, plot_size_wide, font_size, xData, xData_m, figure_idx, 0); 
    figure_list{end+1} = figure_idx; suffix_list{end+1} = 'WV_Diff_PTV_Model'; figure_idx=figure_idx+1;

    if flag.read_wv_multi
        create_pcolor_plot(x, y, comb_AH_MultiPulse-comb_AH_model, 'Absolute Humidity, MultiPulse-ERA5 (g m^{-3})', caxis_diff_AH, smooth_gray_cmap_AH, node, plot_size_wide, font_size, xData, xData_m, figure_idx, 0); 
        figure_list{end+1} = figure_idx; suffix_list{end+1} = 'WV_Diff_MultiPulse_Model'; figure_idx=figure_idx+1;
    end
end






% ---------------------------------------------------
% --- SQUARE PROFILE COMPARISON (Matched to Stats) ---
% ---------------------------------------------------
hf_stat = figure(figure_idx);
hf_stat.Position = plot_size_square; 

% Subplot 1: Accuracy
subplot(2,2,1);
plot(acc_PTV_prof, y_diag, 'b', acc_Std_prof, y_diag, 'r--', 'LineWidth', 2);
grid on; xlim([0 100]); ylim([0 6]); ylabel('Height (km)');
title(['Accuracy (% in \pm', num2str(T_tolerance), ' K)']);

% Subplot 2: Bias (This explains the envelope spike)
subplot(2,2,2);
plot(bias_PTV_prof, y_diag, 'b', bias_Std_prof, y_diag, 'r--', 'LineWidth', 2);
xline(0, 'k:'); grid on; xlim([-5 5]); ylim([0 6]);
title('Median Bias (K)');

% Subplot 3: 90% Error Envelope
subplot(2,2,3);
plot(width_PTV_prof, y_diag, 'b', width_Std_prof, y_diag, 'r--', 'LineWidth', 2);
xline(3, 'k:', '3K Limit'); grid on; xlim([0 10]); ylim([0 6]);
xlabel('Error Magnitude (K)'); ylabel('Height (km)');
title('90% Error Envelope');

% Subplot 4: Legend
subplot(2,2,4); axis off;
legend(subplot(2,2,1), {'PTV', 'Standard'}, 'Location', 'southwest');
title('Retrieval Method');

figure_list{end+1} = figure_idx; 
suffix_list{end+1} = 'T_Final_Quantitative_Comparison'; 
figure_idx = figure_idx + 1;





% ---------------------------------------------
% --- SURFACE COMPARISON TIME SERIES ---
% ---------------------------------------------
if flag.read_wv_multi %
    
    % Call the simplified plotting function (10 arguments total, passing N_DECIMATE_DYNAMIC)
    create_surface_comparison_plot(x, comb_AH_surf, comb_AH_MultiPulse, comb_AH_model, ...
        node, font_size, xData, xData_m, figure_idx, N_DECIMATE_DYNAMIC); 
    
    figure_list{end+1} = figure_idx; 
    suffix_list{end+1} = 'AH_Surface_LowBin_Timeseries'; 
    figure_idx=figure_idx+1; % Increment figure index
end


% AEROSOL/COUNTS (Conditional)
if flag.plot_aerosol_counts
    % Figure X
    create_pcolor_plot(x, y, comb_ABC, 'Aerosol Backscatter Coefficient, PTV (m^{-1} sr^{-1})', caxis_ABC, 'viridis', node, plot_size_wide, font_size, xData, xData_m, figure_idx, 1);
    figure_list{end+1} = figure_idx; suffix_list{end+1} = 'Back_Coeff_PTV_multi'; figure_idx=figure_idx+1;
    
    % Figure X+1
    create_pcolor_plot(x, y, comb_Counts, 'Attenuated Backscatter, 828 nm', caxis_Counts, 'jet', node, plot_size_wide, font_size, xData, xData_m, figure_idx, 1); 
    figure_list{end+1} = figure_idx; suffix_list{end+1} = '828_Counts_multi'; figure_idx=figure_idx+1;
end

% UNCERTAINTY (Conditional)
if flag.plot_uncertainty 
    % Figure X
    create_pcolor_plot(x, y, comb_AH_var, 'Absolute Humidity Standard Uncertainty (g m^{-3})', caxis_uncertainty, smooth_gray_cmap_AH, node, plot_size_wide, font_size, xData, xData_m, figure_idx, 0); 
    figure_list{end+1} = figure_idx; suffix_list{end+1} = 'WV_Standard_Uncertainty'; figure_idx=figure_idx+1;
    
    % Figure X+1
    create_pcolor_plot(x, y, comb_AH_PTV_var, 'Absolute Humidity PTV Uncertainty (g m^{-3})', caxis_uncertainty, smooth_gray_cmap_AH, node, plot_size_wide, font_size, xData, xData_m, figure_idx, 0); 
    figure_list{end+1} = figure_idx; suffix_list{end+1} = 'WV_PTV_Uncertainty'; figure_idx=figure_idx+1;
    
    if flag.read_wv_multi
        % Figure X+2
        create_pcolor_plot(x, y, comb_AH_MultiPulse_var, 'Absolute Humidity MultiPulse Uncertainty (g m^{-3})', caxis_uncertainty, smooth_gray_cmap_AH, node, plot_size_wide, font_size, xData, xData_m, figure_idx, 0); 
        figure_list{end+1} = figure_idx; suffix_list{end+1} = 'WV_MultiPulse_Uncertainty'; figure_idx=figure_idx+1;
    end
    
    if flag.read_temp_std
        % Figure X+3
        create_pcolor_plot(x, y, comb_T_Std_var, 'Temperature Standard Uncertainty (K)', caxis_uncertainty, smooth_gray_cmap_T, node, plot_size_wide, font_size, xData, xData_m, figure_idx, 0); 
        figure_list{end+1} = figure_idx; suffix_list{end+1} = 'T_Standard_Uncertainty'; figure_idx=figure_idx+1; 
    end
end



% ---------------------------------------------
% --- PRODUCT VS. MODEL DENSITY MAPS (CONDITIONAL) ---
% ---------------------------------------------
% AH Density Maps
if flag.plot_ah_density_map
    % AH PTV vs Model
    create_product_vs_model_density(comb_AH_PTV_full, comb_AH_model_full, ...
        'AH PTV vs ERA5 Model Density Map', 'ERA5 Model AH (g m^{-3})', 'MPD PTV AH (g m^{-3})', ...
        AH_density_limits, DENSITY_CLIM, figure_idx, node, plot_size_wide, font_size, cmap_AH); % 
    figure_list{end+1} = figure_idx; 
    suffix_list{end+1} = 'AH_PTV_vs_ERA5_Density'; 
    figure_idx=figure_idx+1;

    % AH Standard vs Model
    create_product_vs_model_density(comb_AH_full, comb_AH_model_full, ...
        'AH Standard vs ERA5 Model Density Map', 'ERA5 Model AH (g m^{-3})', 'MPD Standard AH (g m^{-3})', ...
        AH_density_limits, DENSITY_CLIM, figure_idx, node, plot_size_wide, font_size, cmap_AH); %
    figure_list{end+1} = figure_idx; 
    suffix_list{end+1} = 'AH_Std_vs_ERA5_Density'; 
    figure_idx=figure_idx+1;
    
    if flag.read_wv_multi
        % AH MultiPulse vs Model
        create_product_vs_model_density(comb_AH_MultiPulse_full, comb_AH_model_full, ...
            'AH MultiPulse vs ERA5 Model Density Map', 'ERA5 Model AH (g m^{-3})', 'MPD MultiPulse AH (g m^{-3})', ...
            AH_density_limits, DENSITY_CLIM, figure_idx, node, plot_size_wide, font_size, cmap_AH); 
        figure_list{end+1} = figure_idx; 
        suffix_list{end+1} = 'AH_MP_vs_ERA5_Density'; 
        figure_idx=figure_idx+1;
    end
end

% Temperature Density Maps
if flag.plot_t_density_map
    % T PTV vs Model
    create_product_vs_model_density(comb_T_full, comb_T_model_full, ...
        'T PTV vs ERA5 Model Density Map', 'ERA5 Model T (K)', 'MPD PTV T (K)', ...
        T_density_limits, DENSITY_CLIM, figure_idx, node, plot_size_wide, font_size, cmap_density); % <-- USES cmap_density (Magma)
    figure_list{end+1} = figure_idx; 
    suffix_list{end+1} = 'T_PTV_vs_ERA5_Density'; 
    figure_idx=figure_idx+1;
    
    if flag.read_temp_std
        % T Standard vs Model
        create_product_vs_model_density(comb_T_Std_full, comb_T_model_full, ...
            'T Standard vs ERA5 Model Density Map', 'ERA5 Model T (K)', 'MPD Standard T (K)', ...
            T_density_limits, DENSITY_CLIM, figure_idx, node, plot_size_wide, font_size, cmap_density); % <-- USES cmap_density (Magma)
        figure_list{end+1} = figure_idx; 
        suffix_list{end+1} = 'T_Std_vs_ERA5_Density'; 
        figure_idx=figure_idx+1;
    end
end


% HISTOGRAMS and 2D DENSITY MAPS (Conditional)
if flag.plot_histograms_2d || flag.plot_1d_histograms
    
    % 1D HISTOGRAMS
    if flag.plot_1d_histograms
        % Figure X
        % Note: Histograms use FULL resolution data for better statistical accuracy
        create_1d_histogram(comb_T_full - comb_T_model_full, 'T PTV - ERA5 Model Difference', 'Temperature Difference (K)', T_hist_limits, figure_idx, node, font_size); 
        figure_list{end+1} = figure_idx; suffix_list{end+1} = 'T_Diff_Histogram'; figure_idx=figure_idx+1;
        
        % Figure X+1
        create_1d_histogram(comb_AH_full - comb_AH_model_full, 'AH Standard - ERA5 Model Difference', 'Absolute Humidity Difference (g m^{-3})', AH_hist_limits, figure_idx, node, font_size); 
        figure_list{end+1} = figure_idx; suffix_list{end+1} = 'AH_Diff_Histogram'; figure_idx=figure_idx+1;
    end

    % 2D DENSITY MAPS
    if flag.plot_histograms_2d
        y_range = y;
        
        % Define data based on decimation flag
        if flag.decimate_hist_data
            % Use decimated data for plotting (faster)
            T_PTV_diff_hist = comb_T - comb_T_model;
            T_Std_diff_hist = comb_T_Std - comb_T_model;
            AH_Std_diff_hist = comb_AH - comb_AH_model;
            AH_PTV_diff_hist = comb_AH_PTV - comb_AH_model;
            AH_MultiPulse_diff_hist = comb_AH_MultiPulse - comb_AH_model;
        else
            % Use full resolution data for high accuracy (slower)
            T_PTV_diff_hist = comb_T_full - comb_T_model_full;
            T_Std_diff_hist = comb_T_Std_full - comb_T_model_full;
            AH_Std_diff_hist = comb_AH_full - comb_AH_model_full;
            AH_PTV_diff_hist = comb_AH_PTV_full - comb_AH_model_full;
            AH_MultiPulse_diff_hist = comb_AH_MultiPulse_full - comb_AH_model_full;
        end

        
        % Figure X+2
        create_2d_density_map(T_PTV_diff_hist, y_range, ...
            'T PTV - ERA5 Diff vs. Range (Bin 0.2 K)', 'Temperature Difference (K)', ...
            T_diff_bin_limits, [0 6], T_diff_bin_width, DENSITY_CLIM, figure_idx, node, plot_size_wide, font_size, cmap_density); 
        figure_list{end+1} = figure_idx; suffix_list{end+1} = 'T_Diff_PTV_Histogram_Range'; figure_idx=figure_idx+1;
        
        if flag.read_temp_std
            % Figure X+3
            create_2d_density_map(T_Std_diff_hist, y_range, ... 
                'T Standard - ERA5 Diff vs. Range (Bin 0.2 K)', 'Temperature Difference (K)',...
                T_diff_bin_limits, [0 6], T_diff_bin_width, DENSITY_CLIM, figure_idx, node, plot_size_wide, font_size, cmap_density); 
            figure_list{end+1} = figure_idx; suffix_list{end+1} = 'T_Diff_Standard_Histogram_Range'; figure_idx=figure_idx+1;
        end

        % Figure X+4
        create_2d_density_map(AH_Std_diff_hist, y_range, ...
            'AH Standard - ERA5 Diff vs. Range (Bin 0.2 g m^{-3})', 'Absolute Humidity Difference (g m^{-3})', ...
            AH_diff_bin_limits, [0 6], AH_diff_bin_width, DENSITY_CLIM, figure_idx, node, plot_size_wide, font_size, cmap_AH); 
        figure_list{end+1} = figure_idx; suffix_list{end+1} = 'AH_Diff_Standard_Histogram_Range'; figure_idx=figure_idx+1;
        
        % Figure X+5
        create_2d_density_map(AH_PTV_diff_hist, y_range, ...
            'AH PTV - ERA5 Diff vs. Range (Bin 0.2 g m^{-3})', 'Absolute Humidity Difference (g m^{-3})', ...
            AH_diff_bin_limits, [0 6], AH_diff_bin_width, DENSITY_CLIM, figure_idx, node, plot_size_wide, font_size, cmap_AH); 
        figure_list{end+1} = figure_idx; suffix_list{end+1} = 'AH_PTV_Diff_Histogram_Range'; figure_idx=figure_idx+1;

        if flag.read_wv_multi
            % Figure X+6
            create_2d_density_map(AH_MultiPulse_diff_hist, y_range, ...
                'AH MultiPulse - ERA5 Diff vs. Range (Bin 0.2 g m^{-3})', 'Absolute Humidity Difference (g m^{-3})', ...
                AH_diff_bin_limits, [0 6], AH_diff_bin_width, DENSITY_CLIM, figure_idx, node, plot_size_wide, font_size, cmap_AH); 
            figure_list{end+1} = figure_idx; suffix_list{end+1} = 'AH_MultiPulse_Diff_Histogram_Range'; figure_idx=figure_idx+1;
        end
    end
end

% ---------------------------------------------
% --- PROFILE LINE PLOTS (CONDITIONAL) ---
% ---------------------------------------------
if flag.plot_profile_lines
    % CORRECTED CALL: Use full-resolution time (comb_duration) and full-resolution 2D data (*_full)
    create_profile_plots(comb_duration, y, comb_AH_full, comb_AH_PTV_full, comb_AH_MultiPulse_full, comb_AH_model_full, ...
        comb_T_full, comb_T_Std_full, comb_T_model_full, comb_AH_surf, comb_T_surf, ...
        PROFILE_TIME_TO_PLOT, node, figure_idx);
    
    figure_list{end+1} = figure_idx; suffix_list{end+1} = 'Profile_AH'; figure_idx=figure_idx+1;
    figure_list{end+1} = figure_idx; suffix_list{end+1} = 'Profile_T'; figure_idx=figure_idx+1;
end


% --- PLOT SAVING LOOP (Iterating over created figures only) ---
cd(plot_dir);
plot_size = [100 100 1920 225];
plot_size_square = [100 100 750 750]; 
plot_size_4panel = [100 100 1900 650]; 
plot_size_5panel = [100 100 1900 800]; 
plot_size_7panel = [100 100 1900 890]; 
%plot_size_7panel = [100 100 1900/2 890]; 
num_plots = length(figure_list);

for k_idx = 1:num_plots
    k = figure_list{k_idx}; % Get the actual figure number
    suffix = suffix_list{k_idx}; % Get the corresponding suffix
    
    FigH = figure(k);
    drawnow;
    FigH.Units = 'pixels';
    
    % Determine size based on the specific figure created
    if strcmp(suffix, 'T_WV_7Panel_Absolute')
        FigH.Position = plot_size_7panel;
    elseif strcmp(suffix, 'T_WV_7Panel_Difference')
        FigH.Position = plot_size_7panel;
    elseif strcmp(suffix, 'Core_4Panel_Parameters')
        FigH.Position = plot_size_4panel;
    elseif contains(suffix, 'Histogram') || contains(suffix, 'Density') || contains(suffix, 'Scatter') || contains(suffix, 'Profile')
       FigH.Position = plot_size_square;
    else
        % Default wide size for single pcolor plots
        FigH.Position = plot_size; 
    end
    
    name = char(strcat(node, "_", date_str, '_', suffix));
    exportgraphics(FigH, [name, '.png'], 'Resolution', 150);
    
    % --- CRITICAL EFFICIENCY IMPROVEMENT ---
   % close(FigH); % Close the figure immediately to free up memory
end

disp(['Plotting and saving complete. Time elapsed: ', num2str(toc(tic_plot_save)), ' seconds.']);
disp(['Total script runtime: ', num2str(toc(tic_total)), ' seconds.']);
disp('--- Script End ---');


% ylim([0 3])
% colormap(viridis)
%clim([0 20])



% ------------------------------------------------------------------
% --- LOCAL FUNCTIONS ---
% ------------------------------------------------------------------

function output_matrix = decimate_matrix(input_matrix, N_decimate)
    % Decimates the time (column) dimension of a 2D matrix by averaging N_decimate points.
    
    [N_range, N_time] = size(input_matrix);
    
    % Pad the end of the matrix with NaNs if the size isn't evenly divisible
    N_remainder = mod(N_time, N_decimate);
    if N_remainder ~= 0
        N_pad = N_decimate - N_remainder;
        padding = nan(N_range, N_pad);
        input_matrix = [input_matrix, padding];
        N_time = size(input_matrix, 2);
    end
    
    % Reshape and average: (N_range) x (N_time/N_decimate)
    output_matrix = mean(reshape(input_matrix, N_range, N_decimate, N_time/N_decimate), 2);
    output_matrix = squeeze(output_matrix);
end


% ==========================================================
function availability_percent = calculate_low_range_availability(data_matrix, alt_vector, max_alt_km)
% CALCULATE_LOW_RANGE_AVAILABILITY Calculates the percentage of valid data 
% points below a specified altitude.

    % Find the indices (rows) corresponding to altitudes <= max_alt_km
    low_range_indices = find(alt_vector <= max_alt_km); % both in km 

    if isempty(low_range_indices)
        availability_percent = 0;
        return;
    end
    
    % Extract the low-range subset
    low_range_data = data_matrix(low_range_indices, :);
    
    % Total number of possible data points in this range
    total_possible_points = numel(low_range_data);
    
    % Number of valid (non-NaN) data points
    num_valid_points = sum(isfinite(low_range_data), 'all');
    
    % Calculate availability percentage
    availability_percent = (num_valid_points / total_possible_points) * 100;
end






